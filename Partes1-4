/*****************************************/
// Universidad del Valle de Guatemala
// BE3029 - Electrónica Digital 2
// Abby Barrios - 23137 
// 19/08/25
// Proyecto 1 - Sensor de Temperatura
// MCU: ESP32 DevKit v1
/*****************************************/

//******************************************/
// Librerias
//******************************************/
#include <Arduino.h>
#include <stdint.h>

//******************************************/
// Definiciones
//******************************************/
// PARTE 1 Y 2 
  // Entradas
  #define pinLm35 34 // ADC1 para sensor LM35
  #define pinButton 27 // Botón con pull-up interno

  // LEDs
  #define ledR 14 // Rojo
  #define ledY 12 // Amarillo
  #define ledG 13 // Verde

  // Temperaturas
  const float tGreenMax  = 22.0f;  // t < 22 -> Verde
  const float tYellowMax = 25.0f;  // 22 <= t < 25 -> Amarillo
  //o t >= 25 -> Rojo

  //ADC
  #define adcSamples   30   // muestras para promedio

//PARTE 3
  //Servo
  #define servoPin 4 
  #define servoChan 3 
  #define servoFreqHz 50 
  #define servoResBits 16 
  #define usMin 500 // pulso mínimo (0)
  #define usMax 2500 // pulso máximo (180)

//PARTE 4 
  //Segmentos
  #define pinSegA 23
  #define pinSegB 22
  #define pinSegC 21
  #define pinSegD 19
  #define pinSegE 18
  #define pinSegF 5
  #define pinSegG 17
  #define pinSegDp 16

  //Dígitos
  #define pinDigL 32 //Lefr
  #define pinDigM 33 //Medio
  #define pinDigR 25 //Right

  #define SEG_ON_LEVEL HIGH
  #define SEG_OFF_LEVEL LOW
  #define DIG_ON_LEVEL HIGH 
  #define DIG_OFF_LEVEL (!DIG_ON_LEVEL)

  //ISR
  #define disp_timer_id 1
  #define disp_timer_presc 80
  #define disp_isr_period_us 1000 

  // Multiplexeo
  const uint16_t dispRefreshUsPerDigit = 900;


//******************************************/
// Prototipos de funciones
//******************************************/
//Semáforo
float leerTemperaturaC();
void actualizarSemaforo(float tempC);
bool botonPresionadoEdge();

//Servo
void initServo();
void updateServoFromTemp(float tempC); // Mueve el servo según °C
void writeServoDeg(float deg); 
uint32_t microsecondsToDuty(uint16_t us, uint16_t periodUs, uint8_t resBits);
float mapTempToDeg(float tempC); //Mapeo

//Display de 7 segmentos
void initDisplayIsr(); 
void updateDisplayFromTemp(float tempC);


//******************************************/
// Variables globales
//******************************************/
//Semáforo
  static bool lastBtnState = HIGH;
  static uint32_t tLastDebounce = 0;
  const uint16_t debounceMs = 30;
  static float ultimaTempC = NAN;

//Display
  //0=izq, 1=medio, 2=der
  static volatile uint8_t dispBuf[3] = {10,10,10};
  static volatile bool    dispDp [3] = {false,false,false};

  //Timer y multiplexeo
  static hw_timer_t* dispTimer = nullptr;
  static volatile uint8_t dispIdx = 0;

  //A al G mapa
  static const uint8_t numToSeg[10] = {
    0b0111111, //0
    0b0000110, //1
    0b1011011, //2
    0b1001111, //3
    0b1100110, //4
    0b1101101, //5
    0b1111101, //6
    0b0000111, //7
    0b1111111, //8
    0b1101111  //9
  };

//******************************************/
// ISRs Rutinas de Interrupcion
//******************************************/
void IRAM_ATTR displayIsr() {
  //Apagar todos
  digitalWrite(pinDigL, DIG_OFF_LEVEL);
  digitalWrite(pinDigM, DIG_OFF_LEVEL);
  digitalWrite(pinDigR, DIG_OFF_LEVEL);

  //Dígito
  dispIdx++;
  if (dispIdx >= 3) dispIdx = 0;

  //Cargar segmentos del dígito seleccionado
  uint8_t code = dispBuf[dispIdx];
  bool dpOn    = dispDp[dispIdx];

  if (code <= 9) {
    uint8_t s = numToSeg[code];
    // bits: a b c d e f g
    digitalWrite(pinSegA,  (s & 0b0000001) ? SEG_ON_LEVEL : SEG_OFF_LEVEL);
    digitalWrite(pinSegB,  (s & 0b0000010) ? SEG_ON_LEVEL : SEG_OFF_LEVEL);
    digitalWrite(pinSegC,  (s & 0b0000100) ? SEG_ON_LEVEL : SEG_OFF_LEVEL);
    digitalWrite(pinSegD,  (s & 0b0001000) ? SEG_ON_LEVEL : SEG_OFF_LEVEL);
    digitalWrite(pinSegE,  (s & 0b0010000) ? SEG_ON_LEVEL : SEG_OFF_LEVEL);
    digitalWrite(pinSegF,  (s & 0b0100000) ? SEG_ON_LEVEL : SEG_OFF_LEVEL);
    digitalWrite(pinSegG,  (s & 0b1000000) ? SEG_ON_LEVEL : SEG_OFF_LEVEL);
    digitalWrite(pinSegDp, dpOn ? SEG_ON_LEVEL : SEG_OFF_LEVEL);

    //Encender dígito
    if (dispIdx == 0) digitalWrite(pinDigL, DIG_ON_LEVEL);
    if (dispIdx == 1) digitalWrite(pinDigM, DIG_ON_LEVEL);
    if (dispIdx == 2) digitalWrite(pinDigR, DIG_ON_LEVEL);
  } else {
    digitalWrite(pinSegA, SEG_OFF_LEVEL);
    digitalWrite(pinSegB, SEG_OFF_LEVEL);
    digitalWrite(pinSegC, SEG_OFF_LEVEL);
    digitalWrite(pinSegD, SEG_OFF_LEVEL);
    digitalWrite(pinSegE, SEG_OFF_LEVEL);
    digitalWrite(pinSegF, SEG_OFF_LEVEL);
    digitalWrite(pinSegG, SEG_OFF_LEVEL);
    digitalWrite(pinSegDp, SEG_OFF_LEVEL);
  }
}

//******************************************/
// Configuracion
//******************************************/
void setup() {
  Serial.begin(115200);
  delay(100);
  Serial.println(F("Semáforo"));

  //Botón
  pinMode(pinButton, INPUT_PULLUP);

  //LEDs
  pinMode(ledR, OUTPUT);
  pinMode(ledY, OUTPUT);
  pinMode(ledG, OUTPUT);

  //LM35 Sensor de temp
  analogSetPinAttenuation(pinLm35, ADC_11db);

  //Estado leds
  digitalWrite(ledR, LOW);
  digitalWrite(ledY, LOW);
  digitalWrite(ledG, LOW);

  Serial.println(F("Presionar botón"));

  //Servo
  initServo();
  writeServoDeg(90.0f); //Posición inicial a 90

  //Display de 7 segmentos
    initDisplayIsr();
  if (!isnan(ultimaTempC)) {
    updateDisplayFromTemp(ultimaTempC);
  }

}


//******************************************/
// Loop Principal
//******************************************/
void loop() {
  if (botonPresionadoEdge()) {
    float tempC = leerTemperaturaC();
    ultimaTempC = tempC;
    actualizarSemaforo(tempC); //Encender LEDs
    updateServoFromTemp(tempC); //Mover servo
     updateDisplayFromTemp(tempC); //Muestra valor en display
  }
}

//******************************************/
// Otras funciones
//******************************************/
//LM35 en °C
  float leerTemperaturaC() {
    uint32_t sum_mV = 0;
    for (int k = 0; k < adcSamples; k++) {
      sum_mV += analogReadMilliVolts(pinLm35);
      delay(2);
    }
    float prom_mV = sum_mV / float(adcSamples);
    float tempC   = prom_mV / 10.0f;

    Serial.print(tempC, 1);
    Serial.print(F(", ")); // el color lo completa actualizarSemaforo()

    return tempC;
  }

  //Actualización de semáforo
  void actualizarSemaforo(float tempC) {
    const char* color = "N/A";

    //Estado apagados
    digitalWrite(ledR, LOW);
    digitalWrite(ledY, LOW);
    digitalWrite(ledG, LOW);

    if (tempC < tGreenMax) {
      digitalWrite(ledG, HIGH);
      color = "VERDE";
    } else if (tempC < tYellowMax) {
      digitalWrite(ledY, HIGH);
      color = "AMARILLO";
    } else {
      digitalWrite(ledR, HIGH);
      color = "ROJO";
    }

    Serial.println(color);
  }

  //Detecta flanco de botón
  bool botonPresionadoEdge() {
    bool reading = digitalRead(pinButton);
    if (reading != lastBtnState) {
      tLastDebounce = millis();
      lastBtnState = reading;
    }
    if ((millis() - tLastDebounce) > debounceMs) {
      static bool lastStable = HIGH;
      if (reading != lastStable) {
        lastStable = reading;
        if (reading == LOW) {
          return true;
        }
      }
    }
    return false;
  }

//PARTE 3
  void initServo() {
    ledcSetup(servoChan, servoFreqHz, servoResBits);
    ledcAttachPin(servoPin, servoChan);
  }

  //Para el mapeo de temperatura a un ángulo
  void updateServoFromTemp(float tempC) {
    float deg = mapTempToDeg(tempC);
    writeServoDeg(deg);

    Serial.print(F("Servo: "));
    Serial.print(deg, 1);
    Serial.println(F(" deg"));
  }

  void writeServoDeg(float deg) {
    //ÁNGULO DEL SERVO
    if (deg < 0.0f)   deg = 0.0f;
    if (deg > 180.0f) deg = 180.0f;
    const float us = usMin + (deg / 180.0f) * (usMax - usMin);
    //PWM
    const uint16_t periodUs = 20000;
    const uint32_t duty = microsecondsToDuty((uint16_t)us, periodUs, servoResBits);
    ledcWrite(servoChan, duty);
  }

  //Ancho de pulso a us
  uint32_t microsecondsToDuty(uint16_t us, uint16_t periodUs, uint8_t resBits) {
    const uint32_t maxDuty = (1UL << resBits) - 1UL;
    uint32_t duty = (uint32_t)(( (uint32_t)us * maxDuty ) / periodUs);
    if (duty > maxDuty) duty = maxDuty;
    return duty;
  }

  // °C a ángulo del servo
  float mapTempToDeg(float tempC) {
    const float a0 = 0.0f; //inicio
    const float a1 = 60.0f; //límite en verde
    const float a2 = 120.0f; //amarillo
    const float a3 = 180.0f; //límite en rojo

    if (tempC < tGreenMax) {
      float t0 = 0.0f; //referencia baja
      float t1 = tGreenMax;
      float x  = (tempC - t0) / (t1 - t0);
      if (x < 0) x = 0;
      if (x > 1) x = 1;
      return a0 + x * (a1 - a0);
    } else if (tempC < tYellowMax) {
      // Verde y amarullo
      float t0 = tGreenMax, t1 = tYellowMax;
      float x  = (tempC - t0) / (t1 - t0);
      return a1 + x * (a2 - a1);
    } else {
      float t0 = tYellowMax, t1 = 35.0f; //referencia alta
      if (tempC >= t1) return a3;
      float x  = (tempC - t0) / (t1 - t0);
      return a2 + x * (a3 - a2);
    }
  }

//PARTE 4
  static inline void segWrite(uint8_t pin, bool on) {
    digitalWrite(pin, on ? SEG_ON_LEVEL : SEG_OFF_LEVEL);
  }
  static inline void digWrite(uint8_t pin, bool on) {
    digitalWrite(pin, on ? DIG_ON_LEVEL : DIG_OFF_LEVEL);
  }

  void initDisplayIsr() {
    // Segmentos
    pinMode(pinSegA,  OUTPUT);
    pinMode(pinSegB,  OUTPUT);
    pinMode(pinSegC,  OUTPUT);
    pinMode(pinSegD,  OUTPUT);
    pinMode(pinSegE,  OUTPUT);
    pinMode(pinSegF,  OUTPUT);
    pinMode(pinSegG,  OUTPUT);
    pinMode(pinSegDp, OUTPUT);
    // Dígitos
    pinMode(pinDigL, OUTPUT);
    pinMode(pinDigM, OUTPUT);
    pinMode(pinDigR, OUTPUT);

    // Todo apagado
    segWrite(pinSegA,false); segWrite(pinSegB,false); segWrite(pinSegC,false);
    segWrite(pinSegD,false); segWrite(pinSegE,false); segWrite(pinSegF,false);
    segWrite(pinSegG,false); segWrite(pinSegDp,false);
    digWrite(pinDigL,false); digWrite(pinDigM,false); digWrite(pinDigR,false);

    // Timer: 1us/tick, interrupción cada disp_isr_period_us
    dispTimer = timerBegin(disp_timer_id, disp_timer_presc, true);
    timerAttachInterrupt(dispTimer, &displayIsr, true);
    timerAlarmWrite(dispTimer, disp_isr_period_us, true);
    timerAlarmEnable(dispTimer);
  }

  // Genera decenas/unidades/decimal desde tempC (1 decimal) y actualiza buffer (atómico)
  void updateDisplayFromTemp(float tempC) {
    if (isnan(tempC)) {
      noInterrupts();
      dispBuf[0]=10; dispBuf[1]=10; dispBuf[2]=10;
      dispDp[0]=dispDp[1]=dispDp[2]=false;
      interrupts();
      return;
    }

    // Limitar a 0.0 .. 99.9 (3 dígitos)
    if (tempC < 0.0f)  tempC = 0.0f;
    if (tempC > 99.9f) tempC = 99.9f;

    // Método del esquema: temp*10 → entero → extraer
    int temp10 = (int)roundf(tempC * 10.0f);   // p.ej. 25.7 → 257
    int decenas  = temp10 / 100;               // 2
    temp10      -= decenas * 100;              // 57
    int unidades = temp10 / 10;                // 5
    temp10      -= unidades * 10;              // 7
    int decimal  = temp10;                     // 7

    // Blank en decenas si <10°C
    uint8_t dL = (((int)roundf(tempC)) < 10) ? 10 : (uint8_t)decenas;
    uint8_t dM = (uint8_t)unidades;
    uint8_t dR = (uint8_t)decimal;

    noInterrupts();
    dispBuf[0] = dL;            // izquierda
    dispBuf[1] = dM;            // medio
    dispBuf[2] = dR;            // derecha
    dispDp[0]  = false;
    dispDp[1]  = true;          // punto entre unidades y decimal
    dispDp[2]  = false;
    interrupts();
  }
